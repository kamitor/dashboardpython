name: Release

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write        # required for release-please to create/manage labels

jobs:
  # ── Create or update the release PR ────────────────────────────────────────
  release-please:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name:        ${{ steps.release.outputs.tag_name }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          release-type: python

  # ── Build all platform artifacts when a release is created ─────────────────
  build:
    needs: release-please
    if: needs.release-please.outputs.release_created == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            artifact: windows
          - os: macos-latest
            artifact: macos
          - os: ubuntu-latest
            artifact: linux
    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-python@v6
        with:
          python-version: "3.13"
          cache: pip

      # ── Metadata ────────────────────────────────────────────────────────────
      - name: Set build metadata
        shell: bash
        run: |
          TAG="${{ needs.release-please.outputs.tag_name }}"
          VERSION="${TAG#v}"
          REPO="${GITHUB_REPOSITORY#*/}"
          echo "APP_VERSION=$VERSION"   >> "$GITHUB_ENV"
          echo "REPO_NAME=$REPO"        >> "$GITHUB_ENV"

      # ── Dependencies ─────────────────────────────────────────────────────────
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Install Linux system libraries
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libxkbcommon-x11-0 libxcb-xinerama0 libxcb-cursor0 \
            libegl1 libglib2.0-0

      # ── Windows: generate version resource then build .exe ──────────────────
      - name: Generate Windows version resource
        if: runner.os == 'Windows'
        shell: python
        run: |
          import os, textwrap
          v = os.environ["APP_VERSION"].split(".")
          major, minor, patch = int(v[0]), int(v[1] if len(v)>1 else 0), int(v[2] if len(v)>2 else 0)
          repo = os.environ["REPO_NAME"]
          ver  = os.environ["APP_VERSION"]
          txt = textwrap.dedent(f"""
            VSVersionInfo(
              ffi=FixedFileInfo(
                filevers=({major},{minor},{patch},0), prodvers=({major},{minor},{patch},0),
                mask=0x3f, flags=0x0, OS=0x40004, fileType=0x1, subtype=0x0, date=(0,0)),
              kids=[
                StringFileInfo([StringTable(u'040904B0',[
                  StringStruct(u'CompanyName',      u''),
                  StringStruct(u'FileDescription',  u'{repo}'),
                  StringStruct(u'FileVersion',      u'{ver}'),
                  StringStruct(u'InternalName',     u'{repo}'),
                  StringStruct(u'OriginalFilename', u'{repo}.exe'),
                  StringStruct(u'ProductName',      u'{repo}'),
                  StringStruct(u'ProductVersion',   u'{ver}'),
                ])]),
                VarFileInfo([VarStruct(u'Translation',[1033,1200])])
              ])
          """).strip()
          os.makedirs("packaging", exist_ok=True)
          open("packaging/windows-version.txt","w").write(txt)

      - name: Build Windows .exe
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $icon = if (Test-Path "assets/icon.ico") { @("--icon","assets/icon.ico") } else { @() }
          pyinstaller --clean --noconfirm --onefile --windowed `
            @icon `
            --version-file packaging/windows-version.txt `
            --name "$env:REPO_NAME" `
            app/main.py
          Rename-Item "dist/$env:REPO_NAME.exe" `
            "dist/$env:REPO_NAME-$env:APP_VERSION-windows.exe"

      # ── macOS: build .app bundle, zip it, then wrap in DMG ──────────────────
      - name: Build macOS .app
        if: runner.os == 'macOS'
        run: |
          ICON=""
          [ -f "assets/icon.icns" ] && ICON="--icon assets/icon.icns"
          [ -z "$ICON" ] && [ -f "assets/icon.ico" ] && ICON="--icon assets/icon.ico"
          pyinstaller --clean --noconfirm --onefile --windowed \
            $ICON \
            --name "$REPO_NAME" \
            app/main.py

      - name: Package macOS artifacts (.app.zip + .dmg)
        if: runner.os == 'macOS'
        run: |
          if [ -d "dist/$REPO_NAME.app" ]; then
            # Zip the .app bundle for direct distribution
            cd dist
            zip -r "${REPO_NAME}-${APP_VERSION}-macos.app.zip" "${REPO_NAME}.app"
            cd ..

            # Build a DMG installer
            brew install create-dmg --quiet
            create-dmg \
              --volname "$REPO_NAME" \
              --window-size 600 400 \
              --icon-size 100 \
              --icon "${REPO_NAME}.app" 150 190 \
              --app-drop-link 450 190 \
              "dist/${REPO_NAME}-${APP_VERSION}-macos.dmg" \
              "dist/${REPO_NAME}.app" || true   # create-dmg exits 1 when no code-signing; artifacts still produced

            rm -rf "dist/${REPO_NAME}.app"
          fi

      # ── Linux: build binary, then package .deb / .rpm / .AppImage ───────────
      - name: Build Linux binary
        if: runner.os == 'Linux'
        run: |
          pyinstaller --clean --noconfirm --onefile \
            --name "$REPO_NAME" \
            app/main.py

      - name: Generate .desktop file
        if: runner.os == 'Linux'
        run: |
          export APP_NAME
          APP_NAME=$(echo "$REPO_NAME" | sed 's/-/ /g; s/\b./\u&/g')
          envsubst < packaging/template.desktop > "packaging/${REPO_NAME}.desktop"

      - name: Package Linux .deb and .rpm
        if: runner.os == 'Linux'
        run: |
          curl -fsSL \
            https://github.com/goreleaser/nfpm/releases/download/v2.41.1/nfpm_2.41.1_linux_amd64.tar.gz \
            | tar -xz -C /usr/local/bin nfpm

          export APP_NAME
          APP_NAME=$(echo "$REPO_NAME" | sed 's/-/ /g; s/\b./\u&/g')

          nfpm pkg --packager deb \
            --target "dist/${REPO_NAME}-${APP_VERSION}-amd64.deb"
          nfpm pkg --packager rpm \
            --target "dist/${REPO_NAME}-${APP_VERSION}-x86_64.rpm"

      - name: Package Linux AppImage
        if: runner.os == 'Linux'
        run: |
          # Build AppDir
          mkdir -p AppDir/usr/bin
          cp "dist/$REPO_NAME" AppDir/usr/bin/
          cp "packaging/${REPO_NAME}.desktop" AppDir/

          # Icon — use real asset or 1×1 placeholder so appimagetool doesn't fail
          if [ -f "assets/icon.png" ]; then
            cp assets/icon.png "AppDir/${REPO_NAME}.png"
          else
            python -c "
          import struct, zlib
          def chunk(t, d): c=struct.pack('>I',len(d))+t+d; return c+struct.pack('>I',zlib.crc32(c[4:])&0xffffffff)
          sig=b'\x89PNG\r\n\x1a\n'
          ihdr=chunk(b'IHDR',struct.pack('>IIBBBBB',1,1,8,2,0,0,0))
          idat=chunk(b'IDAT',zlib.compress(b'\x00\xff\x00\x00'))
          iend=chunk(b'IEND',b'')
          open('AppDir/${REPO_NAME}.png','wb').write(sig+ihdr+idat+iend)
          "
          fi

          # appimagetool needs FUSE; --appimage-extract-and-run bypasses that on CI
          wget -q https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          ARCH=x86_64 ./appimagetool-x86_64.AppImage --appimage-extract-and-run \
            AppDir "dist/${REPO_NAME}-${APP_VERSION}-x86_64.AppImage"

          rm "dist/$REPO_NAME"   # remove raw binary; keep packaged formats only

      # ── Upload artifacts ─────────────────────────────────────────────────────
      - uses: actions/upload-artifact@v6
        with:
          name: release-${{ matrix.artifact }}
          path: dist/*

  # ── Attach all artifacts to the GitHub Release ────────────────────────────
  attach:
    runs-on: ubuntu-latest
    needs: [release-please, build]
    steps:
      - uses: actions/download-artifact@v7
        with:
          pattern: release-*
          path: release-assets
          merge-multiple: true

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release-please.outputs.tag_name }}
          files: release-assets/*
